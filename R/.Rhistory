1100000-126924
1100000-126924-289230
682.30+351.34
289230+683846
31-23
8+30
38/365
38/364
4338.55+3797.78
q()
2015-22
215-1989
2015-1989
2006-1989
2007-1988
q()
8/179
library(EDASeq)
q()
library(cancerTiming)
install.packages("cancerTiming")
library(cancerTiming)
help(eventTiming)
data(mutData)#
ACNLOH<-matrix(c(1,3,1,0),ncol=2,nrow=2,byrow=TRUE)#
onlyMuts<-subset(mutData,is.na(rsID) & position <= 1.8E7)#
onlyMuts$t_depth<-onlyMuts$t_ref_count+onlyMuts$t_alt_count#
x<-eventTiming(x=onlyMuts$t_alt_count,m=onlyMuts$t_depth,#
    history=ACNLOH,totalCopy=2,type="CNLOH",normCont=0.22)
q()
library(cancerTiming)
sessionInfo("cancerTiming")
source("~/Documents/RfunctionsGenerally/InternalRPackages/cancerTiming/R/eventTiming.R")
help(eventTiming)
data(mutData)#
ACNLOH<-matrix(c(1,3,1,0),ncol=2,nrow=2,byrow=TRUE)#
onlyMuts<-subset(mutData,is.na(rsID) & position <= 1.8E7)#
onlyMuts$t_depth<-onlyMuts$t_ref_count+onlyMuts$t_alt_count#
x<-eventTiming(x=onlyMuts$t_alt_count,m=onlyMuts$t_depth,#
    history=ACNLOH,totalCopy=2,type="CNLOH",normCont=0.22)
q()
install.packages("gplots")
source("http://bioconductor.org/biocLite.R")
library(GenomicRanges)
biocLite("GenomicRanges")
help('help')
library(cancerTiming)
sessionInfo()
prompt(plotPi0,filename=c("~/Documents/RfunctionsGenerally/InternalRPackages/cancerTiming/man/plotPi0.Rd"))
help(queryHits)
help(queryHits,package="GenomicRanges")
help("queryHits",package="GenomicRanges")
help("queryHits",package="IRanges")
library(GenomicRanges)
library(IRanges)
help("queryHits",package="IRanges")
help(queryHits)
options(repos = c(CRAN="http://cran.r-project.org"))
Sys.which('texi2dvi')
Sys.setenv(PATH = paste("/opt/local/bin", Sys.getenv("PATH"), sep=":"))
options(repos)
options("repos")
drugDf<-data.frame(response=c(1799,2075,1396,3100,1451,3174,1430,1186,1135,873,2061,1053,1846,1156,868,3065,1217,1714,836,642,1305,1426,2433,1534,2147,1777,2291,4077,1288,2919,1063,1183,984,1540,1337,1583),subject=gl(12,1,length=12*3),period=gl(3,12),drug=factor(c(1,3,2,2,3,1,3,1,2,3,1,2,3,2,1,1,2,3,1,2,3,1,2,3,2,1,3,3,1,2,2,3,1,2,3,1),labels=c("A","B","C")),square=gl(4,3,length=12*3))
replications(drugDf[,-1])#
anova(lm(response~square+period+drug + drug:square+period:square,data=drugDf ))
anova(lm(response~square+period+drug + drug:square+period:square + subject,data=drugDf ))
anova(lm(response~square+period+drug + drug:square+period:square + subject+subject:period,data=drugDf ))
factorial(5)
factorial(4)
q()
library(FrF2)
install.packages("FrF2")
library(FrF2)
install.packages("FrF2")
library(FrF2)
q()
taps <- c(11,26,20,56,83,71,15,34,41,6,13,32) #
person <- as.factor(rep(c(1:4), each =3))#
drug <- as.factor(rep(c("P","C","T"), 4))#
tapsdf<-data.frame(taps=taps,person=person,drug=drug)#
tapsdf#
interaction.plot(x.factor=drug, trace.factor=person, response=taps,type="b",pch=c(1,2,3,4),main="With blocking")
tap.aov = aov(taps  ~ person+ drug)#
summary(tap.aov)#
plot(tap.aov$fitted.values, tap.aov$residuals, pch=c(21:24)[drug], col="black",bg=palette()[person]) #
abline(h=0)#
legend("bottomright",levels(drug),pch=21:24,ncol=3,title="Drug")#
legend("right",levels(person),fill=palette(),bg="white",title="Subject")
interaction.plot(x.factor=drug, trace.factor=person, response=taps,type="b",pch=c(1,2,3,4),main="With blocking",lty=1,lwd=2)
par(mfrow=c(1,2))#
interaction.plot(x.factor=drug, trace.factor=person, response=taps,type="b",pch=c(1,2,3,4),main="With blocking",lty=1,lwd=2,col=palette())#
plot(tap.aov$fitted.values, tap.aov$residuals, pch=c(21:24)[drug], col="black",bg=palette()[person]) #
abline(h=0)
par(mfrow=c(1,2))#
interaction.plot(x.factor=drug, trace.factor=person, response=taps,type="b",pch=c(1,2,3,4),main="With blocking",lty=1,lwd=2,col=palette())#
plot(tap.aov$fitted.values, tap.aov$residuals, pch=c(21:24)[drug], col="black",bg=palette()[person]) #
abline(h=0)#
legend("bottomright",levels(drug),pch=21:24,ncol=3,title="Drug")#
legend("right",levels(person),fill=palette(),bg="white",title="Subject")
par(mfrow=c(1,2))#
interaction.plot(x.factor=drug, trace.factor=person, response=taps,type="b",pch=c(1,2,3,4),main="With blocking",lty=1,lwd=2,col=palette())#
plot(tap.aov$fitted.values, tap.aov$residuals, pch=c(21:24)[drug], col="black",bg=palette()[person],cex=2) #
abline(h=0)#
legend("bottomright",levels(drug),pch=21:24,ncol=3,title="Drug")#
legend("right",levels(person),fill=palette(),bg="white",title="Subject")
par(mfrow=c(1,2))#
interaction.plot(x.factor=drug, trace.factor=person, response=taps,type="b",pch=c(1,2,3,4),main="With blocking",lty=1,lwd=2,col=palette())#
plot(tap.aov$fitted.values, tap.aov$residuals, pch=c(21:24)[drug], col="black",bg=palette()[person],cex=2,xlab="Fitted Values",ylab="Residuals") #
abline(h=0)#
legend("bottomright",levels(drug),pch=21:24,ncol=3,title="Drug")#
legend("right",levels(person),fill=palette(),bg="white",title="Subject")
tap.aov = aov(taps  ~ person+ drug)#
summary(tap.aov)#
par(mfrow=c(1,2))#
interaction.plot(x.factor=drug, trace.factor=person, response=taps,type="b",pch=c(1,2,3,4),main="Finger Tapping Data",lty=1,lwd=2,col=palette())#
plot(tap.aov$fitted.values, tap.aov$residuals, pch=c(21:24)[drug], col="black",bg=palette()[person],cex=2,xlab="Fitted Values",ylab="Residuals",main="Fitted v Residuals") #
abline(h=0)#
legend("bottomright",levels(drug),pch=21:24,ncol=3,title="Drug")#
legend("right",levels(person),fill=palette(),bg="white",title="Subject")
tapply(tap.aov$residuals,drug$person,sum)
tapply(tap.aov$residuals,person,sum)
tapply(tap.aov$residuals,drug,sum)
drugDf<-data.frame(response=c(1799,2075,1396,3100,1451,3174,1430,1186,1135,873,2061,1053,1846,1156,868,3065,1217,1714,836,642,1305,1426,2433,1534,2147,1777,2291,4077,1288,2919,1063,1183,984,1540,1337,1583),subject=gl(12,1,length=12*3),period=gl(3,12),drug=factor(c(1,3,2,2,3,1,3,1,2,3,1,2,3,2,1,1,2,3,1,2,3,1,2,3,2,1,3,3,1,2,2,3,1,2,3,1),labels=c("A","B","C")),square=gl(4,3,length=12*3))
drug.aov<-aov(response~square+period+drug +Error(subject),data=drugDf))#
summary(drug.aov)#
par(mfrow=c(1,2))#
interaction.plot(x.factor=drugDf$drug,trace.factor=drugDf$subject,response=drugDf$response,col=palette()[drugDf$square],lty=1,lwd=2,legend=FALSE,type="l",ylab="Response",xlab="Drug Delivery Method",main="Drug Delivery Data")#
points(x=c(1:3)[drugDf$drug],y=drugDf$response,pch=c(23:25)[drugDf$period],col=palette()[drugDf$square],bg=palette()[drugDf$square])#
legend("topleft",c("1","2","3","4"),title="Square",fill=palette()[1:4])#
legend("top",c("1","2","3"),title="Order",pch=c(23:25),ncol=3)
par(mfrow=c(1,2))#
interaction.plot(x.factor=drugDf$drug,trace.factor=drugDf$subject,response=drugDf$response,col=palette()[drugDf$square],lty=1,lwd=2,legend=FALSE,type="l",ylab="Response",xlab="Drug Delivery Method",main="Drug Delivery Data")#
points(x=c(1:3)[drugDf$drug],y=drugDf$response,pch=c(23:25)[drugDf$period],col=palette()[drugDf$square],bg=palette()[drugDf$square])#
legend("topleft",c("1","2","3","4"),title="Square",fill=palette()[1:4])#
legend("top",c("1","2","3"),title="Order",pch=c(23:25),ncol=3)#
#
plot(drug.aov$fitted.values, drug.aov$residuals, pch=c(21:24)[drugDf$drug$], col="black",bg=palette()[drugDf$square],cex=2,xlab="Fitted Values",ylab="Residuals",main="Fitted v Residuals") #
abline(h=0)
plot(drug.aov$fitted.values, drug.aov$residuals, pch=c(21:24)[drugDf$drug], col="black",bg=palette()[drugDf$square],cex=2,xlab="Fitted Values",ylab="Residuals",main="Fitted v Residuals")
drug.aov<-aov(response~square+period+drug +Error(subject),data=drugDf))#
summary(drug.aov)
drug.aov<-aov(response~square+period+drug +Error(subject),data=drugDf)#
summary(drug.aov)
plot(drug.aov$fitted.values, drug.aov$residuals, pch=c(21:24)[drugDf$drug], col="black",bg=palette()[drugDf$square],cex=2,xlab="Fitted Values",ylab="Residuals",main="Fitted v Residuals")
names(drug.aov)
names(taps.aov)
names(tap.aov)
residuals(drug.aov)
dog.aov<-aov(turnover~diabetes+method+diabetes:method+Error(dogs),data=dogs)#
residuals(dog.aov)
dogs<-data.frame(#
	dogs=factor(rep(1:10,each=2)), #
	diabetes=factor(rep(c("No","Yes"),each=10)),#
	method=factor(rep(c("Inject","Infuse"),10)),#
	turnover=c(44,28,33,23,38,34,59,19,46,26,54,42,43,23,55,23,71,27,57,35))#
dog.aov<-aov(turnover~diabetes+method+diabetes:method+Error(dogs),data=dogs)#
summary(dog.aov)
dog.aov<-aov(turnover~diabetes+method+diabetes:method+Error(dogs),data=dogs)#
residuals(dog.aov)
fitted(dog.aov)
aovProj<-proj(dog.aov)#
names(aovProj)#
#get all the effects:#
allTerms<-do.call("cbind",lapply(aovProj[1:3],function(x){x}))#
colnames(allTerms)[3]<-"dog"#
allTerms
aovProj
dog.aov$coef
coef(dog.aov)
aovProj<-proj(dog.aov)#
names(aovProj)#
#get all the effects:#
allTerms<-do.call("cbind",lapply(aovProj[1:3],function(x){x}))#
colnames(allTerms)[3]<-"dog"#
allTerms
rowSums(allTerms[,c("Intercept","diabetes","method","diabetes:method")])
rowSums(allTerms[,c("(Intercept)","diabetes","method","diabetes:method")])
f1<-rowSums(allTerms[,c("(Intercept)","diabetes","method","diabetes:method")])
plot(f1,dogs$turnover-f1)
colSums(allTerms)
plot(f1,dogs$turnover-f1,col=palette()[dogs$dog])
plot(f1,dogs$turnover-f1,col=palette()[dogs$dog],pch=19)
f2<-rowSums(allTerms[,c("(Intercept)","diabetes","dog","method","diabetes:method")])
plot(f2,dogs$turnover-f2,col=palette()[dogs$dog])
plot(f2,dogs$turnover-f2,col=palette()[dogs$dog],pch=19)
plot(f1,dogs$turnover-f1,col=palette()[dogs$dog],pch=19)
setwd('/Users/epurdom/Documents/Classes/158/2015Spring/HandoutsSpring2015')
options(width=80)#
options(continue="  ")#
options(SweaveHooks=list(fig=function()#
              par(mar=c(5.1, 4.1, 1.1, 2.1))))#
outdir<-"~/Documents/Classes/158/2015Spring/HandoutsSpring2015/11SplitPlotOutput"#
setwd(outdir) #make sure output in folder separate from other stuff#
#library(xtable)#
source("~/Documents/Classes/158/RFunctions/multiStripChart.R")#
source("~/Documents/Classes/158/RFunctions/withinBlockScatter.R")#
####################################################
### code chunk number 2: enterdogdata#
####################################################
dogs<-data.frame(#
	dogs=factor(rep(1:10,each=2)), #
	diabetes=factor(rep(c("No","Yes"),each=10)),#
	method=factor(rep(c("Inject","Infuse"),10)),#
	turnover=c(44,28,33,23,38,34,59,19,46,26,54,42,43,23,55,23,71,27,57,35))#
head(dogs)#
####################################################
### code chunk number 3: plotdog#
####################################################
matplot(rbind(dogs[dogs$method=="Infuse","turnover"],dogs[dogs$method=="Inject","turnover"]),type="b",col=c("red","black")[dogs[dogs$method=="Infuse","diabetes"]],lty=1,lwd=2,pch="",ylab="Turnover",xlab="Method",xaxt="n",main="Turnover by dog")#
axis(1,at=c(1,2),c("Infuse","Inject"))#
legend("topleft",levels(dogs$diabetes),fill=c("red","black"),title="Diabetes")#
text(1,dogs[dogs$method=="Infuse","turnover"],as.character(dogs$dogs[dogs$method=="Infuse"]))#
text(2,dogs[dogs$method=="Inject","turnover"],as.character(dogs$dogs[dogs$method=="Inject"]))#
####################################################
### code chunk number 4: badplotdog#
####################################################
#not useful plot#
plot(as.numeric(dogs$diabetes),dogs$turnover,pch=c(1,19)[dogs$method],col=c("red","black")[dogs$diabetes])#
text(as.numeric(dogs$diabetes),dogs$turnover,dogs$dogs,col=c("red","black")[dogs$diabetes],pos=4)#
####################################################
### code chunk number 5: anovaDogAverage#
####################################################
dogAverage<-tapply(dogs$turnover,dogs$dogs,mean)#
dogFac<-factor(tapply(dogs$diabetes,dogs$dogs,unique),levels=c(1,2),labels=levels(dogs$diabetes))#
anova(lm(dogAverage~dogFac))#
####################################################
### code chunk number 6: wrongANOVA#
####################################################
#wrong model#
dd.aov<-aov(turnover~diabetes+method+diabetes:method+dogs,data=dogs)#
summary(dd.aov)#
####################################################
### code chunk number 7: rightAOV#
####################################################
dd.aov<-aov(turnover~diabetes+method+diabetes:method+Error(dogs),data=dogs)#
summary(dd.aov)
coef(dd.aov)
aovProj<-proj(dog.aov)#
names(aovProj)#
#get all the effects:#
allTerms<-do.call("cbind",lapply(aovProj[1:3],function(x){x}))#
colnames(allTerms)[3]<-"dog"#
head(allTerms)
dog.aov<-aov(turnover~diabetes+method+diabetes:method+Error(dogs),data=dogs)#
summary(dog.aov)#
aovProj<-proj(dog.aov)#
names(aovProj)#
#get all the effects:#
allTerms<-do.call("cbind",lapply(aovProj[1:3],function(x){x}))#
colnames(allTerms)[3]<-"dog"#
head(allTerms)
apply(allTerms,2,table)
apply(allTerms[,-ncol(allTerms)],2,table)
apply(allTerms[,-ncol(allTerms)],2,function(x){table(round(x,4))})
names(allTerms)
colnames(allTerms)
apply(allTerms[,-c(3,6)],2,function(x){table(round(x,4))})
apply(allTerms[,-c(1,3,6)],2,function(x){table(round(x,4))})
apply(allTerms[,-c(1,3,6)],2,function(x){unique(round(x,4))})
gpVar<-c(4,-4)#what saw in the diabetes effect#
	sigmasq<-63.5#
	nbtT<-2#
	nwinT<-2#
	nblock<-seq(2,30)#
	power<-sapply(nblock,function(n){ #n is number of blocks per diabetes condition#
		npertreatment<- n # #per level#
		ncpseq<-npertreatment*sum(gpVar^2)/sigmasq #nc factor#
		dfDenom<- (n-1)*nbtT#
		dfNum<-length(gpVar)-1#
		fcutoff<-qf(1-0.05,df=dfNum,df2=dfDenom) #cutoff under the null#
		1-pf(fcutoff,df1=dfNum,df2=dfDenom,ncp=ncpseq) #
	})#
	plot(nblock,power,log="x",type="b",xlab="Numb Blocks Per Between Block Factor",main="Between Factor Power")#
	abline(h=c(0.85,0.9,0.95))
gpVar<-c(4,-4)#what saw in the diabetes effect#
	sigmasq<-63.5#
	nbtT<-2#
	nwinT<-2#
	nblock<-seq(2,30)#
	power<-sapply(nblock,function(n){ #n is number of blocks per diabetes condition#
		npertreatment<- n # #per level#
		ncpseq<-npertreatment*sum(gpVar^2)/sigmasq #nc factor#
		dfDenom<- (n-1)*nbtT#
		dfNum<-length(gpVar)-1#
		fcutoff<-qf(1-0.05,df=dfNum,df2=dfDenom) #cutoff under the null#
		1-pf(fcutoff,df1=dfNum,df2=dfDenom,ncp=ncpseq) #
	})#
	plot(nblock,power,log="x",type="b",xlab="Numb Blocks Per Between Block Factor",main="Between Factor Power")#
	abline(h=c(0.85,0.9,0.95),lty=2)
n<-5
(n-1)*nbtT
summary(dd.aov)
npertreatment<-5#
dfDenom<-4*npertreatment - (4)#
alt<-c(-1.5 ,-1.5 , 3.5, -0.5)#
sigmasq<-4#
ncp<-npertreatment*sum(alt^2)/sigmasq#
plotUnderFCurve<-function(point,nc,direction=c("greater","less"),...){#
	if(direction=="less") x=seq(0,point,len=100) else x<-seq(point,10,len=100)#
	y=df(x,df1=3, df2=dfDenom, ncp=nc) #
	if(direction=="less") polygon(c(x,x[length(x)]), c(y, y[1]), ...)#
	else polygon(c(x,tail(x,1),x[1]), c(y, 0,0), ...)#
}#
ncp<-5*var(c(3,3,8,4))/4#
fx<-function(x){df(x,df1=3, df2=16)}#
cutoff<-qf(1-0.05,df1=3,df2=16)#
curve(fx,0,10,ylab=expression(p(F[obs])))#
plotUnderFCurve(cutoff,0,direction="greater",col="grey")#
axis(1,cutoff,expression(f[alpha]))
fx<-function(x){df(x,df1=3, df2=16)}#
curve(fx,0,10)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=16),0,direction="greater",col="grey")#
fx<-function(x){df(x,df1=3, df2=16,ncp=ncp)}#
curve(fx,0,10,add=TRUE)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=16),nc=ncp,direction="greater",col="black",density=c(10, 20), angle=c(-45, 45))
npertreatment<-5#
dfDenom<-4*npertreatment - (4)#
alt<-c(-1.5 ,-1.5 , 3.5, -0.5)#
sigmasq<-4#
ncp<-npertreatment*sum(alt^2)/sigmasq#
plotUnderFCurve<-function(point,nc,direction=c("greater","less"),...){#
	if(direction=="less") x=seq(0,point,len=100) else x<-seq(point,10,len=100)#
	y=df(x,df1=3, df2=dfDenom, ncp=nc) #
	if(direction=="less") polygon(c(x,x[length(x)]), c(y, y[1]), ...)#
	else polygon(c(x,tail(x,1),x[1]), c(y, 0,0), ...)#
}#
fx<-function(x){df(x,df1=3, df2=16)}#
cutoff<-qf(1-0.05,df1=3,df2=16)#
curve(fx,0,10,ylab=expression(p(F[obs])))#
plotUnderFCurve(cutoff,0,direction="greater",col="grey")#
axis(1,cutoff,expression(f[alpha]))
#redo the null#
fx<-function(x){df(x,df1=3, df2=dfDenom)}#
curve(fx,0,10)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=dfDenom),0,direction="greater",col="grey")#
#alternative#
fx<-function(x){df(x,df1=3, df2=dfDenom,ncp=ncp)}#
curve(fx,0,10,add=TRUE)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=16),nc=ncp,direction="greater",col="black",density=c(10, 20), angle=c(-45, 45))
setwd('/Users/epurdom/Documents/Classes/158/2015Spring/HandoutsSpring2015')
npertreatment<-5#
dfDenom<-4*npertreatment - (4)#
alt<-c(-1.5 ,-1.5 , 3.5, -0.5)/2#
sigmasq<-4#
ncp<-npertreatment*sum(alt^2)/sigmasq#
#redo the null#
fx<-function(x){df(x,df1=3, df2=dfDenom)}#
curve(fx,0,10)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=dfDenom),0,direction="greater",col="grey")#
#alternative#
fx<-function(x){df(x,df1=3, df2=dfDenom,ncp=ncp)}#
curve(fx,0,10,add=TRUE)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=16),nc=ncp,direction="greater",col="black",density=c(10, 20), angle=c(-45, 45))
npertreatment<-5#
dfDenom<-4*npertreatment - (4)#
alt<-c(-1.5 ,-1.5 , 3.5, -0.5)#
sigmasq<-4#
ncp<-npertreatment*sum(alt^2)/sigmasq#
#redo the null#
fx<-function(x){df(x,df1=3, df2=dfDenom)}#
curve(fx,0,10)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=dfDenom),0,direction="greater",col="grey")#
#alternative#
fx<-function(x){df(x,df1=3, df2=dfDenom,ncp=ncp)}#
curve(fx,0,10,add=TRUE)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=16),nc=ncp,direction="greater",col="black",density=c(10, 20), angle=c(-45, 45))
npertreatment<-5#
dfDenom<-4*npertreatment - (4)#
alt<-c(-1.5 ,-1.5 , 3.5, -0.5)/2#
sigmasq<-4#
ncp<-npertreatment*sum(alt^2)/sigmasq#
#redo the null#
fx<-function(x){df(x,df1=3, df2=dfDenom)}#
curve(fx,0,10)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=dfDenom),0,direction="greater",col="grey")#
#alternative#
fx<-function(x){df(x,df1=3, df2=dfDenom,ncp=ncp)}#
curve(fx,0,10,add=TRUE)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=16),nc=ncp,direction="greater",col="black",density=c(10, 20), angle=c(-45, 45))
setwd('/Users/epurdom/Documents/Classes/158/2015Spring/HandoutsSpring2015')
npertreatment<-3#
dfDenom<-4*npertreatment - (4)#
alt<-c(-1.5 ,-1.5 , 3.5, -0.5)#
sigmasq<-4#
ncp<-npertreatment*sum(alt^2)/sigmasq#
#redo the null#
fx<-function(x){df(x,df1=3, df2=dfDenom)}#
curve(fx,0,10)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=dfDenom),0,direction="greater",col="grey")#
#alternative#
fx<-function(x){df(x,df1=3, df2=dfDenom,ncp=ncp)}#
curve(fx,0,10,add=TRUE)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=16),nc=ncp,direction="greater",col="black",density=c(10, 20), angle=c(-45, 45))
setwd('/Users/epurdom/Documents/Classes/158/2015Spring/HandoutsSpring2015')
npertreatment<-3#
dfDenom<-4*npertreatment - (4)#
alt<-c(-1.5 ,-1.5 , 3.5, -0.5)#
sigmasq<-4#
ncp<-npertreatment*sum(alt^2)/sigmasq#
#redo the null#
fx<-function(x){df(x,df1=3, df2=dfDenom)}#
curve(fx,0,10)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=dfDenom),0,direction="greater",col="grey")#
#alternative#
fx<-function(x){df(x,df1=3, df2=dfDenom,ncp=ncp)}#
curve(fx,0,10,add=TRUE)#
plotUnderFCurve(qf(1-0.05,df1=3,df2=dfDenom),nc=ncp,direction="greater",col="black",density=c(10, 20), angle=c(-45, 45))
nseq<-2:50#
groupmeans<-c(-1.5 ,-1.5 , 3.5, -0.5)#
sigmasq<-4#
power<-sapply(nseq,function(n){#
	ncpseq<-n*sum(groupmeans^2)/sigmasq#
	dfDenom<-4*(n-1)#
	fcutoff<-qf(1-0.05,df=3,df2=dfDenom)#
	1-pf(fcutoff,df1=3,df2=4*(n-1),ncp=ncpseq)#
})#
plot(nseq,power,log="x",type="b",xlab="n",main="Large Effect Sizes")#
abline(h=c(0.85,0.9,0.95),lty=2)
nseq<-10:100#
groupmeans<-c(-0.2125,  0.2875 , 0.0375, -0.1125)#
sigmasq<-4#
power<-sapply(nseq,function(n){#
	N<-4*3*3*n#
	ncpseq<-N/4*3*var(groupmeans)/sigmasq#
	dfDenom<-4*3*3*(n-1)#
	#dfDenom<-4*(3*3*n-1) #the df would get if only 1-way with that number of replications in each group#
	fcutoff<-qf(1-0.05,df=3,df2=dfDenom)#
	1-pf(fcutoff,df1=3,df2=dfDenom,ncp=ncpseq)#
})#
plot(nseq,power,log="x",type="b",xlab="n",main="Power Curve for 3-way Factorial")#
abline(h=c(0.85,0.9,0.95),lty=2)
quartz()
nseq<-10:100#
groupmeans<-c(-0.2125,  0.2875 , 0.0375, -0.1125)#
sigmasq<-4#
power<-sapply(nseq,function(n){#
	npertreatment<-n * 3 * 3#
	ncpseq<-npertreatment sum(groupmeans^2)/sigmasq#
	dfDenom<-4*3*3*(n-1)#
	fcutoff<-qf(1-0.05,df=3,df2=dfDenom)#
	1-pf(fcutoff,df1=3,df2=dfDenom,ncp=ncpseq)#
})#
plot(nseq,power,log="x",type="b",xlab="n",main="Power Curve for 3-way Factorial")#
abline(h=c(0.85,0.9,0.95),lty=2)
nseq<-10:100#
groupmeans<-c(-0.2125,  0.2875 , 0.0375, -0.1125)#
sigmasq<-4#
power<-sapply(nseq,function(n){#
	npertreatment<-n * 3 * 3#
	ncpseq<-npertreatment * sum(groupmeans^2)/sigmasq#
	dfDenom<-4*3*3*(n-1)#
	fcutoff<-qf(1-0.05,df=3,df2=dfDenom)#
	1-pf(fcutoff,df1=3,df2=dfDenom,ncp=ncpseq)#
})#
plot(nseq,power,log="x",type="b",xlab="n",main="Power Curve for 3-way Factorial")#
abline(h=c(0.85,0.9,0.95),lty=2)
nseq<-seq(100:1800,length=100)#
groupmeans<-c(-0.2125,  0.2875 , 0.0375, -0.1125)#
sigmasq<-4#
power<-sapply(nseq,function(N){#
	npertreatment<-N/4#
	ncpseq<-npertreatment * sum(groupmeans^2)/sigmasq#
	dfDenom<-N-4*3*3#
	fcutoff<-qf(1-0.05,df=3,df2=dfDenom)#
	1-pf(fcutoff,df1=3,df2=dfDenom,ncp=ncpseq)#
})#
plot(nseq,power,log="x",type="b",xlab="N, total number of observations",main="Power Curve for 3-way Factorial")#
abline(h=c(0.85,0.9,0.95),lty=2)
nseq<-seq(100,1800,length=100)#
groupmeans<-c(-0.2125,  0.2875 , 0.0375, -0.1125)#
sigmasq<-4#
power<-sapply(nseq,function(N){#
	npertreatment<-N/4#
	ncpseq<-npertreatment * sum(groupmeans^2)/sigmasq#
	dfDenom<-N-4*3*3#
	fcutoff<-qf(1-0.05,df=3,df2=dfDenom)#
	1-pf(fcutoff,df1=3,df2=dfDenom,ncp=ncpseq)#
})#
plot(nseq,power,log="x",type="b",xlab="N, total number of observations",main="Power Curve for 3-way Factorial")#
abline(h=c(0.85,0.9,0.95),lty=2)
nseq<-seq(100,2000,length=100)#
groupmeans<-c(-0.2125,  0.2875 , 0.0375, -0.1125)#
sigmasq<-4#
power<-sapply(nseq,function(N){#
	npertreatment<-N/4#
	ncpseq<-npertreatment * sum(groupmeans^2)/sigmasq#
	dfDenom<-N-4*3*3#
	fcutoff<-qf(1-0.05,df=3,df2=dfDenom)#
	1-pf(fcutoff,df1=3,df2=dfDenom,ncp=ncpseq)#
})#
plot(nseq,power,log="x",type="b",xlab="N, total number of observations",main="Power Curve for 3-way Factorial")#
abline(h=c(0.85,0.9,0.95),lty=2)#
@
nseq<-10:100#
groupmeans<-c(0.11,-0.06,-0.05,0.16,0.43,-0.3,0.3,-0.16,0.29,0.45,-0.1,0.38)#
sigmasq<-4#
#ncpseq<-5*var(c(-1.5 ,-1.5 , 3.5, -0.5))/4#
power<-sapply(nseq,function(n){#
	npertreatment<-3*n#
	ncpseq<-npertreatment*(length(groupmeans)-1)*var(groupmeans)/sigmasq#
	dfDenom<-4*3*3*(n-1)#
	dfNum<-length(groupmeans)-(4-1+3-1+1)#
	# dfDenom<-4*(3*3*n-1) #the df would get if only 1-way with that number of replications in each group#
	# dfNum<-length(groupmeans)-1 #the df from numerator if only 1-way with that number of replications in each group#
	fcutoff<-qf(1-0.05,df=dfNum,df2=dfDenom)#
	1-pf(fcutoff,df1=dfNum,df2=dfDenom,ncp=ncpseq)#
})#
plot(nseq,power,log="x",type="b",xlab="n")#
abline(h=c(0.85,0.9,0.95),lty=2)#
abline(v=40.3,lty=2) #number implied by 1-way anova calculation
nsubj<-2:20 #possible values of the number of subjects#
sigmasq<-55.3#
groupmeans<-c(5,-12,7)#
power<-sapply(nsubj,function(n){ #n is number of subjects#
	npertreatment<-n # #per level, n because complete block#
	ncpseq<-npertreatment*sum(groupmeans^2)/sigmasq #nc factor#
	dfDenom<-npertreatment*length(groupmeans)-(n-1+length(groupmeans)-1+1)#
	dfNum<-length(groupmeans)-1#
	fcutoff<-qf(1-0.05,df=dfNum,df2=dfDenom) #cutoff under the null#
	1-pf(fcutoff,df1=dfNum,df2=dfDenom,ncp=ncpseq) #
})#
plot(nsubj,power,log="x",type="b",xlab="Number of blocks")#
abline(h=c(0.85,0.9,0.95),lty=2)
gpVar<-seq(5000,20000 ,length=20) #note that dependent on the scale of the response#
t<-3#
sigmasq<-2379 #from the cow experiment#
power<-sapply(gpVar,function(v){ #v is between group variance#
	npertreatment<-t # numb times see each treatment#
	ncpseq<-t*(t-1)*v/sigmasq#
	dfDenom<-t^2-(t-1+t-1+t-1+1)#
	fcutoff<-qf(1-0.05,df=t-1,df2=dfDenom)#
	1-pf(fcutoff,df1=t-1,df2=dfDenom,ncp=ncpseq)#
})#
plot(gpVar,power,log="x",type="b",xlab="Effect Variance")#
abline(h=c(0.85,0.9,0.95),lty=2)#
abline(v=17236,lty=1) #estimated effect from experiment
#First 5 columns of segData must have column names 'chr','end','start','strand',and 'width'#
#"names of mutData must include 'chr' and 'position'#
mut2Seg<-function(mutData,segData,verbose=TRUE){#
	require(GenomicRanges)#
	require(cancerTiming)#
	if(any(sort(colnames(segData)[1:5])!=c('chr','end','start','strand','width'))) stop("First 5 columns of segData must have column names 'chr','end','start','strand',and 'width'")#
	if(!all(c("chr","position")%in%colnames(mutData))) stop("names of mutData must include 'chr' and 'position'")#
	#check same chromosome names:#
	segChr<-unique(segData$chr)#
	mutChr<-unique(mutData$chr)#
	newChr<-union(segChr,mutChr)#
	if(!all(newChr%in%intersect(segChr,mutChr))){#
		#warning("Not all of the chromosomes shared in mutData and segData, will allow the union of them")#
		if(any(!newChr%in%segChr)){#
			if(verbose){#
				cat("Chromosomes not in segData:\n")#
				print(newChr[!newChr%in%segChr])#
			}#
		}#
		if(any(!newChr%in%mutChr)){#
			if(verbose){#
				cat("Chromosomes not in mutData:\n")#
				print(newChr[!newChr%in%mutChr])#
			}#
		}#
	}	#
	segGr<-GRanges(seqnames =factor(segData$chr,levels=newChr),#
	          ranges = IRanges(segData$start, end=segData$end),strand="*",#
	          segData[,6:ncol(segData)])#
	mutGr<-GRanges(seqnames=factor(mutData$chr, levels=newChr), ranges=IRanges(mutData$position,end=mutData$position))#
	ov<-findOverlaps(segGr,mutGr)#
	combDf<-data.frame(mutData[subjectHits(ov),],#
		seg_start=start(segGr)[queryHits(ov)],seg_end=end(segGr)[queryHits(ov)],#
			as.data.frame(values(segGr)[queryHits(ov),]))#
#
	#check that none match more than 1#
	if(length(unique(subjectHits(ov)))!=length(subjectHits(ov))){#
		isDup<-duplicated(subjectHits(ov))#
		whDup<-which(subjectHits(ov)%in%subjectHits(ov)[which(isDup)])#
		ndups<-table(subjectHits(ov)[whDup])#
		if(verbose){#
			cat("Overlapping Segments with Mutations matching:\n")#
			print(segData[unique(queryHits(ov)[whDup]),])#
		}#
#		stop(length(ndups)," mutations matched more than 1 segment")#
	}#
	#add those with no hits!#
	nmissing<-nrow(mutData)-length(subjectHits(ov))#
	if(nmissing>0){#
		dummyData<-data.frame(seg_start=NA,seg_end=NA,matrix(NA,ncol=ncol(values(segGr)),nrow=nmissing))#
		names(dummyData)<-c("seg_start","seg_end",colnames(values(segGr)))#
		if(length(subjectHits(ov))>0) missDat<-cbind(mutData[-subjectHits(ov),],dummyData)#
		else{#
			missDat<-cbind(mutData,dummyData) #means there were no mutations in these segments!#
			if(verbose) cat("there was no overlap between the mutations and the segments\n")#
		}#
		colnames(missDat)<-make.names(colnames(missDat))#
		colnames(combDf)<-make.names(colnames(combDf))#
		combDf<-rbind(combDf,missDat)#
	}#
	combDf<-combDf[order(numChromosome(combDf$chr),combDf$position),]#
	return(combDf)#
}
help(help)
help(prompt)
prompt(mut2Seg,filename="~/Documents/RfunctionsGenerally/InternalRPackages/cancerTiming/man/mut2Seg.Rd")
library(cancerTiming)
data(mutData)
head(mutData)
help(mutData)
data(hg19chromosomes)
hg19chromosomes<-read.table(.fpath("hg19chromosomes.txt"),stringsAsFactors=FALSE)
25263007<1.8e7
81195210<1.8e7
data(mutData)#
ACNLOH<-matrix(c(1,3,1,0),ncol=2,nrow=2,byrow=TRUE)#
onlyMuts<-subset(mutData,is.na(rsID) & position <= 1.8E7)
dim(onlyMuts)
dim(mutData)
1.8E7
1.8e7
mutData
78636328
78636328<1.8e7
81195210<1.8e7
head(mutData)
segs<-data.frame(chr=c(17,17),start=(1,1.8e7+100),end=c(1.8e7,81195210),strand="*", normCont=0.22,segId=c("CNLOH","Other"))#
segs$width<-segs$end-segs$start+1#
data(mutData)#
colnames(mutData)[1]<-c("chr")#
mut2Seg(mutData,segs)
segs<-data.frame(chr=c(17,17),start=c(1,1.8e7+100),end=c(1.8e7,81195210),strand="*", normCont=0.22,segId=c("CNLOH","Other"))#
segs$width<-segs$end-segs$start+1#
mut2Seg(mutData,segs)
setwd('/Users/epurdom/Documents/RfunctionsGenerally/InternalRPackages/cancerTiming/man')
segs<-segs[,c(1:4,7,5:6)]#
mut2Seg(mutData,segs)
head(mut2Seg(mutData,segs))
data(mutData)#
	colnames(mutData)[1]<-c("chr")#
	colnames(mutData)[grep("t_alt_count",colnames(mutData))]<-"nMutAllele"#
	colnames(mutData)[grep("t_ref_count",colnames(mutData))]<-"nRefAllele"#
	mutData$nReads<-mutData$nMutAllele+mutData$nRefAllele#
	mutData$mutationId<-1:nrow(mutData)#
	#add segmentation annotation -- second region is bogus, only for illustration#
	segs<-data.frame(chr=c(17,17),start=c(1,1.8e7+100),end=c(1.8e7,81195210),strand="*", #
		normCont=0.22,segId=c("Seg1","Seg2"),type=c("CNLOH","SingleGain"))#
	##Create Trivial segmentation annotation for example#
	segs$width<-segs$end-segs$start+1#
	segs<-segs[,c(1:4,7,5:6)]#
	mutId<-mut2Seg(mutData,segs)
mut2Seg<-function(mutData,segData,verbose=TRUE){#
	if(requireNamespace("GenomicRanges", quietly = TRUE) & requireNamespace("IRanges", quietly = TRUE)){ #require(GenomicRanges)#
#
		if(any(!c('chr','end','start') %in% colnames(segData)))) stop("segData must have column names 'chr','start','end','strand',and 'width'")#
		else{#
			segData<-data.frame(segData)#
			if(!'strand' %in% colnames(segData)) segData$strand<-"*"#
			if(!'width' %in% colnames(segData)) segData$width<-segData$end-segData$start+1#
			wh<-sapply(c('chr','start','end','strand','width'),grep,colnames(segData))#
			if(wh<ncol(segData)) segData<-cbind(segData[,wh],segData[,-wh])#
			else segData<-segData[,wh]#
		}#
		if(!all(c("chr","position")%in%colnames(mutData))) stop("names of mutData must include 'chr' and 'position'")#
		#check same chromosome names:#
		segChr<-unique(segData$chr)#
		mutChr<-unique(mutData$chr)#
		newChr<-union(segChr,mutChr)#
		if(!all(newChr%in%intersect(segChr,mutChr))){#
			#warning("Not all of the chromosomes shared in mutData and segData, will allow the union of them")#
			if(any(!newChr%in%segChr)){#
				if(verbose){#
					cat("Chromosomes not in segData:\n")#
					print(newChr[!newChr%in%segChr])#
				}#
			}#
			if(any(!newChr%in%mutChr)){#
				if(verbose){#
					cat("Chromosomes not in mutData:\n")#
					print(newChr[!newChr%in%mutChr])#
				}#
			}#
		}	#
		segGr<-GRanges(seqnames =factor(segData$chr,levels=newChr),#
		          ranges = IRanges(segData$start, end=segData$end),strand="*",#
		          segData[,6:ncol(segData)])#
		mutGr<-GRanges(seqnames=factor(mutData$chr, levels=newChr), ranges=IRanges(mutData$position,end=mutData$position))#
		ov<-findOverlaps(segGr,mutGr)#
		combDf<-data.frame(mutData[subjectHits(ov),],#
			seg_start=start(segGr)[queryHits(ov)],seg_end=end(segGr)[queryHits(ov)],#
				as.data.frame(values(segGr)[queryHits(ov),]))#
#
		#check that none match more than 1#
		if(length(unique(subjectHits(ov)))!=length(subjectHits(ov))){#
			isDup<-duplicated(subjectHits(ov))#
			whDup<-which(subjectHits(ov)%in%subjectHits(ov)[which(isDup)])#
			ndups<-table(subjectHits(ov)[whDup])#
			if(verbose){#
				cat("Overlapping Segments with Mutations matching:\n")#
				print(segData[unique(queryHits(ov)[whDup]),])#
			}#
	#		stop(length(ndups)," mutations matched more than 1 segment")#
		}#
		#add those with no hits!#
		nmissing<-nrow(mutData)-length(subjectHits(ov))#
		if(nmissing>0){#
			dummyData<-data.frame(seg_start=NA,seg_end=NA,matrix(NA,ncol=ncol(values(segGr)),nrow=nmissing))#
			names(dummyData)<-c("seg_start","seg_end",colnames(values(segGr)))#
			if(length(subjectHits(ov))>0) missDat<-cbind(mutData[-subjectHits(ov),],dummyData)#
			else{#
				missDat<-cbind(mutData,dummyData) #means there were no mutations in these segments!#
				if(verbose) cat("there was no overlap between the mutations and the segments\n")#
			}#
			colnames(missDat)<-make.names(colnames(missDat))#
			colnames(combDf)<-make.names(colnames(combDf))#
			combDf<-rbind(combDf,missDat)#
		}#
		combDf<-combDf[order(numChromosome(combDf$chr),combDf$position),]#
		return(combDf)#
	}#
	else{stop("Sorry, this little helper function requires the package GenomicRanges, part of bioConductor. Please install this function before using.")}#
}
mut2Seg<-function(mutData,segData,verbose=TRUE){#
	if(requireNamespace("GenomicRanges", quietly = TRUE) & requireNamespace("IRanges", quietly = TRUE)){ #require(GenomicRanges)#
#
		if(any(!c('chr','end','start') %in% colnames(segData))) stop("segData must have column names 'chr','start','end','strand',and 'width'")#
		else{#
			segData<-data.frame(segData)#
			if(!'strand' %in% colnames(segData)) segData$strand<-"*"#
			if(!'width' %in% colnames(segData)) segData$width<-segData$end-segData$start+1#
			wh<-sapply(c('chr','start','end','strand','width'),grep,colnames(segData))#
			if(wh<ncol(segData)) segData<-cbind(segData[,wh],segData[,-wh])#
			else segData<-segData[,wh]#
		}#
		if(!all(c("chr","position")%in%colnames(mutData))) stop("names of mutData must include 'chr' and 'position'")#
		#check same chromosome names:#
		segChr<-unique(segData$chr)#
		mutChr<-unique(mutData$chr)#
		newChr<-union(segChr,mutChr)#
		if(!all(newChr%in%intersect(segChr,mutChr))){#
			#warning("Not all of the chromosomes shared in mutData and segData, will allow the union of them")#
			if(any(!newChr%in%segChr)){#
				if(verbose){#
					cat("Chromosomes not in segData:\n")#
					print(newChr[!newChr%in%segChr])#
				}#
			}#
			if(any(!newChr%in%mutChr)){#
				if(verbose){#
					cat("Chromosomes not in mutData:\n")#
					print(newChr[!newChr%in%mutChr])#
				}#
			}#
		}	#
		segGr<-GRanges(seqnames =factor(segData$chr,levels=newChr),#
		          ranges = IRanges(segData$start, end=segData$end),strand="*",#
		          segData[,6:ncol(segData)])#
		mutGr<-GRanges(seqnames=factor(mutData$chr, levels=newChr), ranges=IRanges(mutData$position,end=mutData$position))#
		ov<-findOverlaps(segGr,mutGr)#
		combDf<-data.frame(mutData[subjectHits(ov),],#
			seg_start=start(segGr)[queryHits(ov)],seg_end=end(segGr)[queryHits(ov)],#
				as.data.frame(values(segGr)[queryHits(ov),]))#
#
		#check that none match more than 1#
		if(length(unique(subjectHits(ov)))!=length(subjectHits(ov))){#
			isDup<-duplicated(subjectHits(ov))#
			whDup<-which(subjectHits(ov)%in%subjectHits(ov)[which(isDup)])#
			ndups<-table(subjectHits(ov)[whDup])#
			if(verbose){#
				cat("Overlapping Segments with Mutations matching:\n")#
				print(segData[unique(queryHits(ov)[whDup]),])#
			}#
	#		stop(length(ndups)," mutations matched more than 1 segment")#
		}#
		#add those with no hits!#
		nmissing<-nrow(mutData)-length(subjectHits(ov))#
		if(nmissing>0){#
			dummyData<-data.frame(seg_start=NA,seg_end=NA,matrix(NA,ncol=ncol(values(segGr)),nrow=nmissing))#
			names(dummyData)<-c("seg_start","seg_end",colnames(values(segGr)))#
			if(length(subjectHits(ov))>0) missDat<-cbind(mutData[-subjectHits(ov),],dummyData)#
			else{#
				missDat<-cbind(mutData,dummyData) #means there were no mutations in these segments!#
				if(verbose) cat("there was no overlap between the mutations and the segments\n")#
			}#
			colnames(missDat)<-make.names(colnames(missDat))#
			colnames(combDf)<-make.names(colnames(combDf))#
			combDf<-rbind(combDf,missDat)#
		}#
		combDf<-combDf[order(numChromosome(combDf$chr),combDf$position),]#
		return(combDf)#
	}#
	else{stop("Sorry, this little helper function requires the package GenomicRanges, part of bioConductor. Please install this function before using.")}#
}
segs<-data.frame(chr=c(17,17),start=c(1,1.8e7+100),end=c(1.8e7,81195210),normCont=0.22,segId=c("CNLOH","Other"))#
	##Trivial segmentation annotation for example#
	mutId<-mut2Seg(mutData,segs)
setwd('/Users/epurdom/Documents/RfunctionsGenerally/InternalRPackages/cancerTiming/R')
mut2Seg<-function(mutData,segData,verbose=TRUE){#
	if(requireNamespace("GenomicRanges", quietly = TRUE) & requireNamespace("IRanges", quietly = TRUE)){ #require(GenomicRanges)#
#
		if(any(!c('chr','end','start') %in% colnames(segData))) stop("segData must have column names 'chr','start','end','strand',and 'width'")#
		else{#
			segData<-data.frame(segData)#
			if(!'strand' %in% colnames(segData)) segData$strand<-"*"#
			if(!'width' %in% colnames(segData)) segData$width<-segData$end-segData$start+1#
			wh<-sapply(c('chr','start','end','strand','width'),grep,colnames(segData))#
			if(length(wh)<ncol(segData)) segData<-cbind(segData[,wh],segData[,-wh])#
			else segData<-segData[,wh]#
		}#
		if(!all(c("chr","position")%in%colnames(mutData))) stop("names of mutData must include 'chr' and 'position'")#
		#check same chromosome names:#
		segChr<-unique(segData$chr)#
		mutChr<-unique(mutData$chr)#
		newChr<-union(segChr,mutChr)#
		if(!all(newChr%in%intersect(segChr,mutChr))){#
			#warning("Not all of the chromosomes shared in mutData and segData, will allow the union of them")#
			if(any(!newChr%in%segChr)){#
				if(verbose){#
					cat("Chromosomes not in segData:\n")#
					print(newChr[!newChr%in%segChr])#
				}#
			}#
			if(any(!newChr%in%mutChr)){#
				if(verbose){#
					cat("Chromosomes not in mutData:\n")#
					print(newChr[!newChr%in%mutChr])#
				}#
			}#
		}	#
		segGr<-GRanges(seqnames =factor(segData$chr,levels=newChr),#
		          ranges = IRanges(segData$start, end=segData$end),strand="*",#
		          segData[,6:ncol(segData)])#
		mutGr<-GRanges(seqnames=factor(mutData$chr, levels=newChr), ranges=IRanges(mutData$position,end=mutData$position))#
		ov<-findOverlaps(segGr,mutGr)#
		combDf<-data.frame(mutData[subjectHits(ov),],#
			seg_start=start(segGr)[queryHits(ov)],seg_end=end(segGr)[queryHits(ov)],#
				as.data.frame(values(segGr)[queryHits(ov),]))#
#
		#check that none match more than 1#
		if(length(unique(subjectHits(ov)))!=length(subjectHits(ov))){#
			isDup<-duplicated(subjectHits(ov))#
			whDup<-which(subjectHits(ov)%in%subjectHits(ov)[which(isDup)])#
			ndups<-table(subjectHits(ov)[whDup])#
			if(verbose){#
				cat("Overlapping Segments with Mutations matching:\n")#
				print(segData[unique(queryHits(ov)[whDup]),])#
			}#
	#		stop(length(ndups)," mutations matched more than 1 segment")#
		}#
		#add those with no hits!#
		nmissing<-nrow(mutData)-length(subjectHits(ov))#
		if(nmissing>0){#
			dummyData<-data.frame(seg_start=NA,seg_end=NA,matrix(NA,ncol=ncol(values(segGr)),nrow=nmissing))#
			names(dummyData)<-c("seg_start","seg_end",colnames(values(segGr)))#
			if(length(subjectHits(ov))>0) missDat<-cbind(mutData[-subjectHits(ov),],dummyData)#
			else{#
				missDat<-cbind(mutData,dummyData) #means there were no mutations in these segments!#
				if(verbose) cat("there was no overlap between the mutations and the segments\n")#
			}#
			colnames(missDat)<-make.names(colnames(missDat))#
			colnames(combDf)<-make.names(colnames(combDf))#
			combDf<-rbind(combDf,missDat)#
		}#
		combDf<-combDf[order(numChromosome(combDf$chr),combDf$position),]#
		return(combDf)#
	}#
	else{stop("Sorry, this little helper function requires the package GenomicRanges, part of bioConductor. Please install this function before using.")}#
}
segs<-data.frame(chr=c(17,17),start=c(1,1.8e7+100),end=c(1.8e7,81195210),normCont=0.22,segId=c("CNLOH","Other"))#
	##Trivial segmentation annotation for example#
	mutId<-mut2Seg(mutData,segs)
head(mutId)
data(mutData)#
	colnames(mutData)[1]<-c("chr")#
	colnames(mutData)[grep("t_alt_count",colnames(mutData))]<-"nMutAllele"#
	colnames(mutData)[grep("t_ref_count",colnames(mutData))]<-"nRefAllele"#
	mutData$nReads<-mutData$nMutAllele+mutData$nRefAllele#
	mutData$mutationId<-1:nrow(mutData)#
	#add segmentation annotation -- second region is bogus, only for illustration#
	segs<-data.frame(chr=c(17,17),start=c(1,1.8e7+100),end=c(1.8e7,81195210),#
		normCont=0.22,segId=c("Seg1","Seg2"),type=c("CNLOH","SingleGain"))
mutId<-mut2Seg(mutData,segs)
eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22,CI=TRUE)
sessionInfo()
install.packages("cancerTiming")
eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22,CI=TRUE)
sessionInfo()
#######analyze each of the data sets#
eventTimingOverList<-function(dfList,normCont,eventArgs){#
	###used for timing straightforward #
	#assume dfList is list of data per sample; each sample must have data frame consisting of all mutations with the following columns:#
		#type one of c("Other","CNLOH","SingleGain","Diploid","DoubleGain")#
		#segId saying for each mutation, what segment it is in. Can not contain a "."#
		#nMutAllele == number of reads with mutation#
		#nReads == total number of reads#
		#mutationId -- a unique id for each mutation#
	#eventArgs=list of arguments passed to eventTiming via 'do.call'. Should NOT contain the arguments 'x','m','history','totalCopy','type','mutationId' or 'normCont'#
#
	if(any(sapply(dfList,function(x){any(!c("segId","type","nMutAllele","nReads","mutationId")%in%names(x))}))) stop("dfList elements are missing required column names")#
	if(any(sapply(dfList,function(x){length(grep("[.]",x$segId))>0}))) stop("segId cannot contain a period")#
	if(is.null(names(dfList))) names(dfList)<-paste("Sample",1:length(dfList),sep="")#
	if(length(normCont)!=length(dfList)) stop("dfList and normCont must be of the same length (1 per sample)")#
	whCall<-lapply(dfList,function(x){tapply(x$segId,factor(x$type,levels=c("Other","CNLOH","SingleGain","Diploid","DoubleGain")),unique)})#
	mapply(whCall,normCont,dfList,FUN=function(x,nc,dat){#
		ACNLOH<-makeEventHistory(totalCopy=2,type="LOH")[[1]]#
		eventCNLOH<-lapply(x[["CNLOH"]],function(segId){#
			subdat<-dat[which(dat$segId==segId),]#
			#print(segId)#
	#		print(dim(subdat))#
			out<-do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
				history=ACNLOH,totalCopy=2,type="CNLOH",mutationId=subdat$mutationId,#
				normCont=nc),eventArgs))#
		})#
		names(eventCNLOH)<-x[["CNLOH"]]#
		AGain<-makeEventHistory(totalCopy=3,type="gain")[[1]]#
		eventGain<-lapply(x[["SingleGain"]],function(segId){#
			subdat<-dat[which(dat$segId==segId),]#
			#print(segId)#
			# print(dim(subdat))#
			do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
				history=AGain,totalCopy=3,type="gain",mutationId=subdat$mutationId,#
				normCont=nc),eventArgs))#
		})#
		names(eventGain)<-x[["SingleGain"]]#
		ADGain<-makeEventHistory(totalCopy=4,type="gain")[[1]]#
		eventDGain<-lapply(x[["DoubleGain"]],function(segId){#
			subdat<-dat[which(dat$segId==segId),]#
			#print(segId)#
			# print(dim(subdat))#
			do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
				history=ADGain,totalCopy=4,type="gain",mutationId=subdat$mutationId,#
				normCont=nc),eventArgs))#
		})#
		names(eventDGain)<-x[["DoubleGain"]]#
		return(list(SingleGain=eventGain,CNLOH=eventCNLOH,DoubleGain=eventDGain))#
	},SIMPLIFY=FALSE)#
}#
#
getPi0Summary<-function(eventList,CI=TRUE){ #
	xmle<-lapply(eventList,.getPiSingle,CI=CI)#
	xmle<-data.frame(Sample=rep(names(xmle),times=sapply(xmle,nrow)),do.call(rbind,xmle))#
	rankWInSample<-do.call("rbind",tapply(1:nrow(xmle),xmle$Sample, function(ii){#
		p<-xmle$pi0[ii]#
		r<-rep(NA,length(p))#
		r[!is.na(p)]<-rank(p[!is.na(p)])#
		return(data.frame(rank=r,segId=xmle$segId[ii],Sample=xmle$Sample[ii]))#
	}))#
	xmle$rank<-rankWInSample$rank[match(paste(xmle$Sample,xmle$segId),paste(rankWInSample$Sample,rankWInSample$segId))]#
	return(xmle)#
}#
#
.getPiSingle<-function(estList,CI){#
	pi0<-sapply(unlist(estList,recursive=FALSE),function(x){x$pi["Stage0"]})#
	if(length(pi0)>0){#
		vals<-strsplit(names(unlist(estList,recursive=FALSE)),"[.]")	#
		nam<-sapply(vals,.subset2,2)#
		type<-sapply(vals,.subset2,1)#
		N<-sapply(unlist(estList,recursive=FALSE),function(x){x$summaryTable[2,]})#
		if(CI){#
			ui<-sapply(unlist(estList,recursive=FALSE),function(x){x$piCI["Stage0",2]})#
			li<-sapply(unlist(estList,recursive=FALSE),function(x){x$piCI["Stage0",1]})#
			out<-data.frame(pi0=pi0,lCI=li,uCI=ui,N=N,type=type,segId=nam)			#
		}#
		else{#
			out<-data.frame(pi0=pi0,N=N,type=type,segId=nam)			#
		}#
		row.names(out)<-NULL#
		return(out)#
	}#
	else{#
		if(CI) return(data.frame(pi0=NA,lCI=NA,uCI=NA,N=NA,type=NA,segId=NA))#
		else return(data.frame(pi0=NA,N=NA,type=NA,segId=NA))#
	}#
}
eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22,CI=TRUE)
eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)
eventTimingOverList<-function(dfList,normCont,eventArgs=NULL){#
	###used for timing straightforward #
	#assume dfList is list of data per sample; each sample must have data frame consisting of all mutations with the following columns:#
		#type one of c("Other","CNLOH","SingleGain","Diploid","DoubleGain")#
		#segId saying for each mutation, what segment it is in. Can not contain a "."#
		#nMutAllele == number of reads with mutation#
		#nReads == total number of reads#
		#mutationId -- a unique id for each mutation#
	#eventArgs=list of arguments passed to eventTiming via 'do.call'. Should NOT contain the arguments 'x','m','history','totalCopy','type','mutationId' or 'normCont'#
#
	if(any(sapply(dfList,function(x){any(!c("segId","type","nMutAllele","nReads","mutationId")%in%names(x))}))) stop("dfList elements are missing required column names")#
	if(any(sapply(dfList,function(x){length(grep("[.]",x$segId))>0}))) stop("segId cannot contain a period")#
	if(is.null(names(dfList))) names(dfList)<-paste("Sample",1:length(dfList),sep="")#
	if(length(normCont)!=length(dfList)) stop("dfList and normCont must be of the same length (1 per sample)")#
	whCall<-lapply(dfList,function(x){tapply(x$segId,factor(x$type,levels=c("Other","CNLOH","SingleGain","Diploid","DoubleGain")),unique)})#
	mapply(whCall,normCont,dfList,FUN=function(x,nc,dat){#
		ACNLOH<-makeEventHistory(totalCopy=2,type="LOH")[[1]]#
		eventCNLOH<-lapply(x[["CNLOH"]],function(segId){#
			subdat<-dat[which(dat$segId==segId),]#
			#print(segId)#
	#		print(dim(subdat))#
			out<-do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
				history=ACNLOH,totalCopy=2,type="CNLOH",mutationId=subdat$mutationId,#
				normCont=nc),eventArgs))#
		})#
		names(eventCNLOH)<-x[["CNLOH"]]#
		AGain<-makeEventHistory(totalCopy=3,type="gain")[[1]]#
		eventGain<-lapply(x[["SingleGain"]],function(segId){#
			subdat<-dat[which(dat$segId==segId),]#
			#print(segId)#
			# print(dim(subdat))#
			do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
				history=AGain,totalCopy=3,type="gain",mutationId=subdat$mutationId,#
				normCont=nc),eventArgs))#
		})#
		names(eventGain)<-x[["SingleGain"]]#
		ADGain<-makeEventHistory(totalCopy=4,type="gain")[[1]]#
		eventDGain<-lapply(x[["DoubleGain"]],function(segId){#
			subdat<-dat[which(dat$segId==segId),]#
			#print(segId)#
			# print(dim(subdat))#
			do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
				history=ADGain,totalCopy=4,type="gain",mutationId=subdat$mutationId,#
				normCont=nc),eventArgs))#
		})#
		names(eventDGain)<-x[["DoubleGain"]]#
		return(list(SingleGain=eventGain,CNLOH=eventCNLOH,DoubleGain=eventDGain))#
	},SIMPLIFY=FALSE)#
}
eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)
getPigetPi0Summary<-function(eventList,CI=TRUE){ #
	xmle<-lapply(eventList,.getPiSingle,CI=CI)#
	xmle<-data.frame(Sample=rep(names(xmle),times=sapply(xmle,nrow)),do.call(rbind,xmle))#
	rankWInSample<-do.call("rbind",tapply(1:nrow(xmle),xmle$Sample, function(ii){#
		p<-xmle$pi0[ii]#
		r<-rep(NA,length(p))#
		r[!is.na(p)]<-rank(p[!is.na(p)])#
		return(data.frame(rank=r,segId=xmle$segId[ii],Sample=xmle$Sample[ii]))#
	}))#
	xmle$rank<-rankWInSample$rank[match(paste(xmle$Sample,xmle$segId),paste(rankWInSample$Sample,rankWInSample$segId))]#
	return(xmle)#
}#
#
.getPiSingle<-function(estList,CI){#
	pi0<-sapply(unlist(estList,recursive=FALSE),function(x){x$pi["Stage0"]})#
	if(length(pi0)>0){#
		vals<-strsplit(names(unlist(estList,recursive=FALSE)),"[.]")	#
		nam<-sapply(vals,.subset2,2)#
		type<-sapply(vals,.subset2,1)#
		N<-sapply(unlist(estList,recursive=FALSE),function(x){x$summaryTable[2,]})#
		if(CI){#
			ui<-sapply(unlist(estList,recursive=FALSE),function(x){x$piCI["Stage0",2]})#
			li<-sapply(unlist(estList,recursive=FALSE),function(x){x$piCI["Stage0",1]})#
			out<-data.frame(pi0=pi0,lCI=li,uCI=ui,N=N,type=type,segId=nam)			#
		}#
		else{#
			out<-data.frame(pi0=pi0,N=N,type=type,segId=nam)			#
		}#
		row.names(out)<-NULL#
		return(out)#
	}#
	else{#
		if(CI) return(data.frame(pi0=NA,lCI=NA,uCI=NA,N=NA,type=NA,segId=NA))#
		else return(data.frame(pi0=NA,N=NA,type=NA,segId=NA))#
	}#
}
getPi0Summary(eventOut)
eventOut
head(mutId)
dim(mutId)
table(mutId$segId)
table(mutId$segId[mutId$nReads>10])
eventTimingOverList<-function(dfList,normCont,eventArgs=NULL){#
	###used for timing straightforward #
	#assume dfList is list of data per sample; each sample must have data frame consisting of all mutations with the following columns:#
		#type one of c("Other","CNLOH","SingleGain","Diploid","DoubleGain")#
		#segId saying for each mutation, what segment it is in. Can not contain a "."#
		#nMutAllele == number of reads with mutation#
		#nReads == total number of reads#
		#mutationId -- a unique id for each mutation#
	#eventArgs=list of arguments passed to eventTiming via 'do.call'. Should NOT contain the arguments 'x','m','history','totalCopy','type','mutationId' or 'normCont'#
#
	if(any(sapply(dfList,function(x){any(!c("segId","type","nMutAllele","nReads","mutationId")%in%names(x))}))) stop("dfList elements are missing required column names")#
	if(any(sapply(dfList,function(x){length(grep("[.]",x$segId))>0}))) stop("segId cannot contain a period")#
	if(is.null(names(dfList))) names(dfList)<-paste("Sample",1:length(dfList),sep="")#
	if(length(normCont)!=length(dfList)) stop("dfList and normCont must be of the same length (1 per sample)")#
#
	whCall<-lapply(dfList,function(x){tapply(x$segId,factor(x$type,levels=c("Other","CNLOH","SingleGain","Diploid","DoubleGain")),unique)})#
	mapply(whCall,normCont,dfList,FUN=function(x,nc,dat){#
		if(length(x[["CNLOH"]])>0){#
			ACNLOH<-makeEventHistory(totalCopy=2,type="LOH")[[1]]#
			eventCNLOH<-lapply(x[["CNLOH"]],function(segId){#
				subdat<-dat[which(dat$segId==segId),]#
				#print(segId)#
		#		print(dim(subdat))#
				out<-do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
					history=ACNLOH,totalCopy=2,type="CNLOH",mutationId=subdat$mutationId,#
					normCont=nc),eventArgs))#
			})#
			names(eventCNLOH)<-x[["CNLOH"]]#
		}#
		else eventCNLOH<-NULL#
		if(length(x[["SingleGain"]])>0){#
			AGain<-makeEventHistory(totalCopy=3,type="gain")[[1]]#
			eventGain<-lapply(x[["SingleGain"]],function(segId){#
				subdat<-dat[which(dat$segId==segId),]#
				#print(segId)#
				# print(dim(subdat))#
				do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
					history=AGain,totalCopy=3,type="gain",mutationId=subdat$mutationId,#
					normCont=nc),eventArgs))#
			})#
			names(eventGain)<-x[["SingleGain"]]			#
		}#
		else eventGain<-NULL#
		if(length(x[["DoubleGain"]])>0){#
			ADGain<-makeEventHistory(totalCopy=4,type="gain")[[1]]#
			eventDGain<-lapply(x[["DoubleGain"]],function(segId){#
			subdat<-dat[which(dat$segId==segId),]#
			#print(segId)#
			# print(dim(subdat))#
			do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
				history=ADGain,totalCopy=4,type="gain",mutationId=subdat$mutationId,#
				normCont=nc),eventArgs))#
				})#
			names(eventDGain)<-x[["DoubleGain"]]#
		}#
		else eventDGain<-NULL#
		return(list(SingleGain=eventGain,CNLOH=eventCNLOH,DoubleGain=eventDGain))#
	},SIMPLIFY=FALSE)#
}
eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)
names(eventOut)
names(eventOut[[1]])
eventOut
eventTimingOverList
debug(eventTimingOverList)
eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)
eventTimingOverList<-function(dfList,normCont,eventArgs=NULL){#
	###used for timing straightforward #
	#assume dfList is list of data per sample; each sample must have data frame consisting of all mutations with the following columns:#
		#type one of c("Other","CNLOH","SingleGain","Diploid","DoubleGain")#
		#segId saying for each mutation, what segment it is in. Can not contain a "."#
		#nMutAllele == number of reads with mutation#
		#nReads == total number of reads#
		#mutationId -- a unique id for each mutation#
	#eventArgs=list of arguments passed to eventTiming via 'do.call'. Should NOT contain the arguments 'x','m','history','totalCopy','type','mutationId' or 'normCont'#
#
	if(any(sapply(dfList,function(x){any(!c("segId","type","nMutAllele","nReads","mutationId")%in%names(x))}))) stop("dfList elements are missing required column names")#
	if(any(sapply(dfList,function(x){length(grep("[.]",x$segId))>0}))) stop("segId cannot contain a period")#
	if(is.null(names(dfList))) names(dfList)<-paste("Sample",1:length(dfList),sep="")#
	if(length(normCont)!=length(dfList)) stop("dfList and normCont must be of the same length (1 per sample)")#
#
	whCall<-lapply(dfList,function(x){tapply(x$segId,factor(x$type,levels=c("Other","CNLOH","SingleGain","Diploid","DoubleGain")),unique)})#
	singleSampleFunction<-function(x,nc,dat){#
		if(length(x[["CNLOH"]])>0){#
			ACNLOH<-makeEventHistory(totalCopy=2,type="LOH")[[1]]#
			eventCNLOH<-lapply(x[["CNLOH"]],function(segId){#
				subdat<-dat[which(dat$segId==segId),]#
				#print(segId)#
		#		print(dim(subdat))#
				out<-do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
					history=ACNLOH,totalCopy=2,type="CNLOH",mutationId=subdat$mutationId,#
					normCont=nc),eventArgs))#
			})#
			names(eventCNLOH)<-x[["CNLOH"]]#
		}#
		else eventCNLOH<-NULL#
		if(length(x[["SingleGain"]])>0){#
			AGain<-makeEventHistory(totalCopy=3,type="gain")[[1]]#
			eventGain<-lapply(x[["SingleGain"]],function(segId){#
				subdat<-dat[which(dat$segId==segId),]#
				#print(segId)#
				# print(dim(subdat))#
				do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
					history=AGain,totalCopy=3,type="gain",mutationId=subdat$mutationId,#
					normCont=nc),eventArgs))#
			})#
			names(eventGain)<-x[["SingleGain"]]			#
		}#
		else eventGain<-NULL#
		if(length(x[["DoubleGain"]])>0){#
			ADGain<-makeEventHistory(totalCopy=4,type="gain")[[1]]#
			eventDGain<-lapply(x[["DoubleGain"]],function(segId){#
			subdat<-dat[which(dat$segId==segId),]#
			#print(segId)#
			# print(dim(subdat))#
			do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
				history=ADGain,totalCopy=4,type="gain",mutationId=subdat$mutationId,#
				normCont=nc),eventArgs))#
				})#
			names(eventDGain)<-x[["DoubleGain"]]#
		}#
		else eventDGain<-NULL#
		return(list(SingleGain=eventGain,CNLOH=eventCNLOH,DoubleGain=eventDGain))#
	}#
	mapply(whCall,normCont,dfList,FUN=singleSampleFunction,SIMPLIFY=FALSE)#
}
debug(eventTimingOverList)
eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)
debug(singleSampleFunction)
whCall
x
x[["CNLOH"]]
Q
segs<-data.frame(chr=c(17,17),start=c(1,1.8e7+100),end=c(1.8e7,81195210),#
		normCont=0.22,segId=c("Seg1","Seg2"),type=c("CNLOH","CNLOH"))#
	##Create Trivial segmentation annotation for example#
	mutId<-mut2Seg(mutData,segs)#
	eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)
whCall
whCall[[1]]
help(tapply)
Q
eventTimingOverList<-function(dfList,normCont,eventArgs=NULL){#
	###used for timing straightforward #
	#assume dfList is list of data per sample; each sample must have data frame consisting of all mutations with the following columns:#
		#type one of c("Other","CNLOH","SingleGain","Diploid","DoubleGain")#
		#segId saying for each mutation, what segment it is in. Can not contain a "."#
		#nMutAllele == number of reads with mutation#
		#nReads == total number of reads#
		#mutationId -- a unique id for each mutation#
	#eventArgs=list of arguments passed to eventTiming via 'do.call'. Should NOT contain the arguments 'x','m','history','totalCopy','type','mutationId' or 'normCont'#
#
	if(any(sapply(dfList,function(x){any(!c("segId","type","nMutAllele","nReads","mutationId")%in%names(x))}))) stop("dfList elements are missing required column names")#
	if(any(sapply(dfList,function(x){length(grep("[.]",x$segId))>0}))) stop("segId cannot contain a period")#
	if(is.null(names(dfList))) names(dfList)<-paste("Sample",1:length(dfList),sep="")#
	if(length(normCont)!=length(dfList)) stop("dfList and normCont must be of the same length (1 per sample)")#
#
	whCall<-lapply(dfList,function(x){tapply(x$segId,factor(x$type,levels=c("Other","CNLOH","SingleGain","Diploid","DoubleGain")),unique,simplify = FALSE)})#
	singleSampleFunction<-function(x,nc,dat){#
		if(length(x[["CNLOH"]])>0){#
			ACNLOH<-makeEventHistory(totalCopy=2,type="LOH")[[1]]#
			eventCNLOH<-lapply(x[["CNLOH"]],function(segId){#
				subdat<-dat[which(dat$segId==segId),]#
				#print(segId)#
		#		print(dim(subdat))#
				out<-do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
					history=ACNLOH,totalCopy=2,type="CNLOH",mutationId=subdat$mutationId,#
					normCont=nc),eventArgs))#
			})#
			names(eventCNLOH)<-x[["CNLOH"]]#
		}#
		else eventCNLOH<-NULL#
		if(length(x[["SingleGain"]])>0){#
			AGain<-makeEventHistory(totalCopy=3,type="gain")[[1]]#
			eventGain<-lapply(x[["SingleGain"]],function(segId){#
				subdat<-dat[which(dat$segId==segId),]#
				#print(segId)#
				# print(dim(subdat))#
				do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
					history=AGain,totalCopy=3,type="gain",mutationId=subdat$mutationId,#
					normCont=nc),eventArgs))#
			})#
			names(eventGain)<-x[["SingleGain"]]			#
		}#
		else eventGain<-NULL#
		if(length(x[["DoubleGain"]])>0){#
			ADGain<-makeEventHistory(totalCopy=4,type="gain")[[1]]#
			eventDGain<-lapply(x[["DoubleGain"]],function(segId){#
			subdat<-dat[which(dat$segId==segId),]#
			#print(segId)#
			# print(dim(subdat))#
			do.call(eventTiming,c(list(x=subdat$nMutAllele, m=subdat$nReads, #
				history=ADGain,totalCopy=4,type="gain",mutationId=subdat$mutationId,#
				normCont=nc),eventArgs))#
				})#
			names(eventDGain)<-x[["DoubleGain"]]#
		}#
		else eventDGain<-NULL#
		return(list(SingleGain=eventGain,CNLOH=eventCNLOH,DoubleGain=eventDGain))#
	}#
	mapply(whCall,normCont,dfList,FUN=singleSampleFunction,SIMPLIFY=FALSE)#
}
eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)
eventOut
getPi0Summary(eventOut)
traceback()
.getPiSingle(eventOut[[1]])
.getPiSingle(eventOut[[1]],CI=TRUE)
debug(.getPiSingle)
.getPiSingle(eventOut[[1]],CI=TRUE)
pi0
ui
li
Q
.getPiSingle<-function(estList,CI){#
	pi0<-sapply(unlist(estList,recursive=FALSE),function(x){x$pi["Stage0"]})#
	if(length(pi0)>0){#
		vals<-strsplit(names(unlist(estList,recursive=FALSE)),"[.]")	#
		nam<-sapply(vals,.subset2,2)#
		type<-sapply(vals,.subset2,1)#
		N<-sapply(unlist(estList,recursive=FALSE),function(x){x$summaryTable[2,]})#
		if(CI){#
			ui<-sapply(unlist(estList,recursive=FALSE),function(x){if("piCI" %in% names(x)) x$piCI["Stage0",2] else NA})#
			li<-sapply(unlist(estList,recursive=FALSE),function(x){if("piCI" %in% names(x)) x$piCI["Stage0",1] else NA})#
			out<-data.frame(pi0=pi0,lCI=li,uCI=ui,N=N,type=type,segId=nam)			#
		}#
		else{#
			out<-data.frame(pi0=pi0,N=N,type=type,segId=nam)			#
		}#
		row.names(out)<-NULL#
		return(out)#
	}#
	else{#
		if(CI) return(data.frame(pi0=NA,lCI=NA,uCI=NA,N=NA,type=NA,segId=NA))#
		else return(data.frame(pi0=NA,N=NA,type=NA,segId=NA))#
	}#
}
.getPiSingle(eventOut[[1]],CI=TRUE)
getPi0Summary(eventOut)
segs<-data.frame(chr=c(17,17),start=c(1,1.8e7+100),end=c(1.8e7,81195210),#
		normCont=0.22,segId=c("Seg1","Seg2"),type=c("CNLOH","SingleGain"))#
	##Create Trivial segmentation annotation for example#
	mutId<-mut2Seg(mutData,segs)#
	eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)#
	getPi0Summary(eventOut)
.getPiSingle<-function(estList,CI){#
	pi0<-sapply(unlist(estList,recursive=FALSE),function(x){x$pi["Stage0"]})#
	if(length(pi0)>0){#
		vals<-strsplit(names(unlist(estList,recursive=FALSE)),"[.]")	#
		nam<-sapply(vals,.subset2,2)#
		type<-sapply(vals,.subset2,1)#
		N<-sapply(unlist(estList,recursive=FALSE),function(x){x$summaryTable[2,]})#
		if(CI){#
			ui<-sapply(unlist(estList,recursive=FALSE),function(x){if("piCI" %in% names(x)) x$piCI["Stage0",2] else NA})#
			li<-sapply(unlist(estList,recursive=FALSE),function(x){if("piCI" %in% names(x)) x$piCI["Stage0",1] else NA})#
			out<-data.frame(pi0=pi0,lCI=li,uCI=ui,N=N,type=type,segId=nam)			#
		}#
		else{#
			out<-data.frame(pi0=pi0,N=N,type=type,segId=nam)			#
		}#
		row.names(out)<-NULL#
		out<-out[order(out$segId),]#
		return(out)#
	}#
	else{#
		if(CI) return(data.frame(pi0=NA,lCI=NA,uCI=NA,N=NA,type=NA,segId=NA))#
		else return(data.frame(pi0=NA,N=NA,type=NA,segId=NA))#
	}#
}
segs<-data.frame(chr=c(17,17),start=c(1,1.8e7+100),end=c(1.8e7,81195210),#
		normCont=0.22,segId=c("Seg1","Seg2"),type=c("CNLOH","SingleGain"))#
	##Create Trivial segmentation annotation for example#
	mutId<-mut2Seg(mutData,segs)#
	eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)#
	getPi0Summary(eventOut)
getPi0Summary<-function(eventList,CI=TRUE){ #
	xmle<-lapply(eventList,.getPiSingle,CI=CI)#
	xmle<-data.frame(Sample=rep(names(xmle),times=sapply(xmle,nrow)),do.call(rbind,xmle))#
	rankWInSample<-do.call("rbind",tapply(1:nrow(xmle),xmle$Sample, function(ii){#
		p<-xmle$pi0[ii]#
		r<-rep(NA,length(p))#
		r[!is.na(p)]<-rank(p[!is.na(p)])#
		return(data.frame(rank=r,segId=xmle$segId[ii],Sample=xmle$Sample[ii]))#
	}))#
	xmle$rankInSample<-rankWInSample$rank[match(paste(xmle$Sample,xmle$segId),paste(rankWInSample$Sample,rankWInSample$segId))]#
	return(xmle)#
}
segs<-data.frame(chr=c(17,17),start=c(1,1.8e7+100),end=c(1.8e7,81195210),#
		normCont=0.22,segId=c("Seg1","Seg2"),type=c("CNLOH","SingleGain"))#
	##Create Trivial segmentation annotation for example#
	mutId<-mut2Seg(mutData,segs)#
	eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)#
	getPi0Summary(eventOut)
eventOut<-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)
library(cancerTiming)
help(eventTimintOverList)
sessionInfo()
help(eventTimingOverList)
q()
